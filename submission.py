# -*- coding: utf-8 -*-
"""lin_reg.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cuLpSkIR86nVyiJk6g3PxGN4SdG9GfNv
"""

import matplotlib.pyplot as plt
import numpy as np
import torch
import pandas as pd

tr=pd.read_csv("train.csv")

x=[]
for i in range(0,891):
    x.append((tr["Pclass"].as_matrix())[i])
    if (tr["Sex"].as_matrix())[i]=="male":
        x.append(1)
    if (tr["Sex"].as_matrix())[i]=="female":
        x.append(0)
    x.append(int((tr["Age"].as_matrix())[i])) if not np.isnan((tr["Age"].as_matrix())[i]) else x.append("29")

y=[]
for i in range(0,891):
    if (tr["Survived"].as_matrix())[i]==0:
        y.append(-1)
    else:
        y.append(+1)
# y=tr["Survived"].as_matrix()
# Using non-iterative algorithm of finding parameter theta
xvec=np.reshape(x,(891,3))
xvec=xvec.astype(np.float)
yvec=np.reshape(y,(891,1))
yvec=yvec.astype(np.float)

# theta=np.reshape(np.random.randn(3,),(3,1))
# for i in range(0,891):
#     h=lambda k : 1 + np.dot(np.reshape(theta,(1,3)),xvec[k])
#     loss=1/2*(h(i)-y[i])**2
#     print('loss=',loss)

# using xvec.transpose() for transpose
theta=np.matmul(np.matmul(np.linalg.inv(np.matmul(xvec.transpose(),xvec)),xvec.transpose()),yvec)
print(theta)

# plt.plot(x,y,'ro')
# plt.show()

# Let us use Stochastic Gradient Descent

# a=1 # Just to start with
# b=1
# h=lambda x:a+b*x
def descent(alpha,er):
    i=0
    converge=False
    a=5
    # b=theta[0]
    while not converge:
        h=lambda k : a + np.dot(np.reshape(theta,(1,3)),xvec[k])
        # h1=h(i)
        # y1=y[i]
        # loss=1/2*(h1-y1)**2
        # loss=0
        # for j in range(0,62):
        #     loss+=1/2*(h(x[j])-y[j])**2
        # (loss>er) and 
        if (i<891):
            h1=h(i)
            y1=y[i]
            a=a-alpha*(h1-y1)
            # b=b-alpha*b*(h1-y1)
            loss=0
            for j in range(0,62):
                loss+=1/2*(h(j)-y[j])**2
            i=i+1
            # print("iteration:",i," loss:",loss)
        else :
            # print("iteration:",i," loss:",loss)
            return a
            converge=True
    # y2=[]
    # for j in range(0,62):
    #     y2.append(a+b*x[j])
    # plt.plot(x,y2)
    # plt.plot(x,y,'ro')
    # plt.show()
ag=descent(10**(-2),1)
print(ag,theta,"\n")
h=lambda k : ag + np.dot(np.reshape(theta,(1,3)),z[k])
h1=lambda k : 1 if h(i)>0 else 0
# for i in range(0,891):
#     print(h(i),y[i])
# win=[]
# for i in range(0,891):
#     h=lambda k : ag + np.dot(np.reshape(theta,(1,3)),xvec[k])
#     h1=lambda k : 1 if h(i)>0 else -1
#     loss=1/2*(h1(i)-y[i])**2
#     if loss==0:
#         win.append(i)
#     print('loss=',loss)
# print("Correct predictions=",np.size(win))

# Lets start our predictions-
def sigmoid(x):
    ans=1/(1+np.exp(-x))
    return ans

df=pd.read_csv("test.csv")
data1=df[['PassengerId']]
z=[]
for i in range(0,418):
    z.append((df["Pclass"].as_matrix())[i])
    if (df["Sex"].as_matrix())[i]=="male":
        z.append(1)
    if (df["Sex"].as_matrix())[i]=="female":
        z.append(0)
    z.append(int((df["Age"].as_matrix())[i])) if not np.isnan((df["Age"].as_matrix())[i]) else z.append("29")
z=np.reshape(z,(418,3))
z=z.astype(np.float)
results=[]
for i in range(0,418):
    results.append(h1(i))

data1.insert(1,'Survived',results)
data1.to_csv('results.csv',index=False)

